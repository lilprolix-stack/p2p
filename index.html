<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glass LAN Messenger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
        .message-in { align-self: flex-start; background: rgba(255,255,255,0.15); border-radius: 16px 16px 16px 4px; }
        .message-out { align-self: flex-end; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 16px 16px 4px 16px; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
    </style>
</head>
<body class="flex items-center justify-center p-4 text-white">

    <div class="glass w-full max-w-6xl h-[90vh] rounded-3xl overflow-hidden flex shadow-2xl">
        <!-- Sidebar -->
        <div class="w-1/4 min-w-[250px] border-r border-white/10 flex flex-col bg-black/10">
            <div class="p-6">
                <h1 class="text-xl font-bold flex items-center gap-2 tracking-wide">
                    <i data-lucide="ghost" class="text-indigo-400"></i> GhostLAN
                </h1>
                <div class="text-xs text-white/40 mt-1">ID: <span id="myIdDisplay" class="font-mono text-indigo-300">...</span></div>
            </div>
            <div id="userList" class="flex-1 overflow-y-auto p-3 space-y-2">
                <div class="text-white/30 text-sm text-center mt-10 animate-pulse">Scanning network...</div>
            </div>
            <div class="p-4 border-t border-white/10">
                <button onclick="clearAllHistory()" class="w-full py-2 text-xs text-white/40 hover:text-red-400 hover:bg-red-500/10 rounded-lg transition flex items-center justify-center gap-2">
                    <i data-lucide="trash-2" class="w-3"></i> Wipe All Data
                </button>
            </div>
        </div>

        <!-- Chat Area -->
        <div id="chatPlaceholder" class="flex-1 flex flex-col items-center justify-center text-white/30">
            <div class="w-24 h-24 bg-white/5 rounded-full flex items-center justify-center mb-6 animate-bounce">
                <i data-lucide="radio" class="w-10 h-10"></i>
            </div>
            <p>Waiting for connection...</p>
        </div>

        <div id="chatWindow" class="hidden flex-1 flex flex-col bg-gradient-to-br from-transparent to-black/20">
            <div class="p-4 border-b border-white/10 flex justify-between items-center backdrop-blur-md bg-white/5">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-indigo-500 rounded-full flex items-center justify-center font-bold" id="activeUserAvatar">?</div>
                    <div>
                        <h2 id="activeUserName" class="font-medium">Device</h2>
                        <span class="text-green-400 text-xs flex items-center gap-1 font-mono">
                            <span class="w-1.5 h-1.5 bg-green-400 rounded-full animate-pulse"></span> P2P ENCRYPTED
                        </span>
                    </div>
                </div>
                <button onclick="deleteChatWithActiveUser()" class="p-2 hover:bg-white/10 rounded-full text-white/60 transition">
                    <i data-lucide="eraser"></i>
                </button>
            </div>

            <div id="messages" class="flex-1 overflow-y-auto p-6 flex flex-col gap-3">
                <!-- Messages go here -->
            </div>

            <div class="p-4">
                <div class="glass p-1.5 rounded-2xl flex gap-2 items-center">
                    <label class="p-3 cursor-pointer hover:bg-white/10 rounded-xl transition text-white/70">
                        <i data-lucide="paperclip" class="w-5 h-5"></i>
                        <!-- Пока выключено для простоты -->
                        <input type="file" id="fileInput" class="hidden" disabled>
                    </label>
                    <input type="text" id="msgInput" placeholder="Type a message..." autocomplete="off"
                           class="flex-1 bg-transparent border-none text-white focus:ring-0 placeholder-white/30 text-sm h-10">
                    <button onclick="sendMessage()" class="bg-indigo-600 hover:bg-indigo-500 p-3 rounded-xl text-white transition shadow-lg shadow-indigo-500/30">
                        <i data-lucide="send" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // ВСТАВЬ СЮДА СВОЙ URL ВОРКЕРА (БЕЗ 'wss://', теперь 'https://')
        // Пример: 'https://twilight-mouse-a26f.lil-pro-lix.workers.dev'
        const WORKER_URL = 'https://twilight-mouse-a26f.lil-pro-lix.workers.dev';

        const myId = Math.random().toString(36).substr(2, 6).toUpperCase();
        document.getElementById('myIdDisplay').innerText = myId;

        let activePeerId = null;
        let connections = {}; // {peerId: {pc, dc, connected}}
        let history = JSON.parse(localStorage.getItem('chatHistory') || '{}');
        
        // --- API & POLLING ---
        
        async function api(path, data) {
            try {
                const opts = data ? { method: 'POST', body: JSON.stringify(data) } : {};
                const res = await fetch(`${WORKER_URL}${path}`, opts);
                return data ? null : await res.json();
            } catch (e) { console.error("API Error", e); return null; }
        }

        // 1. Говорим серверу "Я тут" каждые 4 секунды
        setInterval(() => api('/heartbeat', { id: myId }), 4000);

        // 2. Ищем соседей каждые 5 секунд
        setInterval(async () => {
            const users = await api('/users');
            if (users) renderUserList(users.filter(id => id !== myId));
        }, 5000);

        // 3. Проверяем входящие сигналы каждую 1.5 секунды
        setInterval(async () => {
            const msgs = await api(`/check?id=${myId}`);
            if (!msgs) return;
            for (const msg of msgs) {
                console.log("Got signal from", msg.from, msg.data.type);
                handleSignal(msg.from, msg.data);
            }
        }, 1500);

        function sendSignal(to, data) {
            api('/signal', { to, from: myId, data });
        }

        // --- WEBRTC CORE ---

        function initiateConnection(peerId) {
            if (connections[peerId]) return;
            console.log("Connecting to", peerId);
            setupPeer(peerId, true);
        }

        function setupPeer(peerId, isInitiator) {
            const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            const conn = { pc, dc: null, connected: false };
            connections[peerId] = conn;

            if (isInitiator) {
                const dc = pc.createDataChannel("chat");
                setupDataChannel(dc, peerId);
                conn.dc = dc;
                
                pc.createOffer().then(offer => {
                    pc.setLocalDescription(offer);
                    sendSignal(peerId, { type: 'offer', sdp: offer });
                });
            }

            pc.ondatachannel = (e) => {
                conn.dc = e.channel;
                setupDataChannel(e.channel, peerId);
            };

            pc.onicecandidate = (e) => {
                if (e.candidate) sendSignal(peerId, { type: 'candidate', candidate: e.candidate });
            };
            
            pc.onconnectionstatechange = () => {
                if(pc.connectionState === 'connected') {
                    conn.connected = true;
                    updateUserUI(peerId, true);
                }
                if(pc.connectionState === 'disconnected') {
                     conn.connected = false;
                     delete connections[peerId];
                     updateUserUI(peerId, false);
                }
            };

            return conn;
        }

        async function handleSignal(from, data) {
            let conn = connections[from];
            if (!conn) conn = setupPeer(from, false);

            if (data.type === 'offer') {
                await conn.pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                const answer = await conn.pc.createAnswer();
                await conn.pc.setLocalDescription(answer);
                sendSignal(from, { type: 'answer', sdp: answer });
            } else if (data.type === 'answer') {
                await conn.pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            } else if (data.type === 'candidate') {
                await conn.pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        }

        function setupDataChannel(dc, peerId) {
            dc.onopen = () => {
                console.log("CHANNEL OPEN with", peerId);
                updateUserUI(peerId, true);
                if (activePeerId === peerId) renderMessages();
            };
            dc.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'chat') {
                    saveMessage(peerId, msg.text, 'in');
                } else if (msg.type === 'delete') {
                    deleteMessageLocal(peerId, msg.msgId);
                } else if (msg.type === 'wipe') {
                    history[peerId] = [];
                    saveHistory();
                    if(activePeerId === peerId) renderMessages();
                }
            };
        }

        // --- UI & LOGIC ---

        function renderUserList(users) {
            const list = document.getElementById('userList');
            list.innerHTML = '';
            
            if(users.length === 0) {
                 list.innerHTML = '<div class="text-white/30 text-xs text-center mt-10">Searching...<br>Open this site on another device</div>';
                 return;
            }

            users.forEach(uid => {
                const isConnected = connections[uid]?.connected;
                const div = document.createElement('div');
                div.className = `p-3 rounded-xl cursor-pointer transition flex items-center gap-3 ${activePeerId === uid ? 'bg-white/10' : 'hover:bg-white/5'}`;
                div.onclick = () => {
                    initiateConnection(uid); // Пробуем соединиться при клике
                    openChat(uid);
                };
                div.innerHTML = `
                    <div class="w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm ${isConnected ? 'bg-green-500 text-white' : 'bg-white/10 text-white/50'}">
                        ${uid.substr(0,2)}
                    </div>
                    <div>
                        <div class="text-sm font-medium text-white">${uid}</div>
                        <div class="text-xs ${isConnected ? 'text-green-400' : 'text-white/30'}">
                            ${isConnected ? 'Connected' : 'Click to connect'}
                        </div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function updateUserUI(uid, connected) {
            // Перерисовка списка для обновления статуса
            const list = document.getElementById('userList');
            // Простой способ: мы полагаемся на setInterval, но можно форсировать
            // renderUserList(...) - тут пропустим для краткости, цикл обновит.
        }

        function openChat(uid) {
            activePeerId = uid;
            document.getElementById('chatPlaceholder').classList.add('hidden');
            document.getElementById('chatWindow').classList.remove('hidden');
            document.getElementById('activeUserName').innerText = `Device ${uid}`;
            document.getElementById('activeUserAvatar').innerText = uid.substr(0,2);
            renderMessages();
        }

        function sendMessage() {
            const input = document.getElementById('msgInput');
            const text = input.value.trim();
            if (!text || !activePeerId || !connections[activePeerId]?.dc) return;

            const msgId = Date.now();
            const payload = { type: 'chat', text, id: msgId };
            
            connections[activePeerId].dc.send(JSON.stringify(payload));
            saveMessage(activePeerId, text, 'out', msgId);
            input.value = '';
        }

        document.getElementById('msgInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        function saveMessage(peerId, text, direction, id = Date.now()) {
            if (!history[peerId]) history[peerId] = [];
            history[peerId].push({ id, text, direction });
            saveHistory();
            if (activePeerId === peerId) renderMessages();
        }

        function saveHistory() {
            localStorage.setItem('chatHistory', JSON.stringify(history));
        }

        function renderMessages() {
            const container = document.getElementById('messages');
            container.innerHTML = '';
            const msgs = history[activePeerId] || [];
            
            msgs.forEach(msg => {
                const div = document.createElement('div');
                div.className = `p-3 max-w-[75%] relative group text-sm ${msg.direction === 'out' ? 'message-out' : 'message-in'}`;
                div.innerHTML = `
                    ${msg.text}
                    <button onclick="reqDelete('${msg.id}')" class="absolute top-1/2 -translate-y-1/2 ${msg.direction === 'out' ? '-left-8' : '-right-8'} opacity-0 group-hover:opacity-100 transition text-red-400 p-1">
                        <i data-lucide="x" class="w-4 h-4"></i>
                    </button>
                `;
                container.appendChild(div);
            });
            container.scrollTop = container.scrollHeight;
            lucide.createIcons();
        }

        function reqDelete(msgId) {
            deleteMessageLocal(activePeerId, msgId);
            if(connections[activePeerId]?.dc) {
                connections[activePeerId].dc.send(JSON.stringify({ type: 'delete', msgId }));
            }
        }

        function deleteMessageLocal(peerId, msgId) {
            if(history[peerId]) {
                history[peerId] = history[peerId].filter(m => m.id != msgId);
                saveHistory();
                if(activePeerId === peerId) renderMessages();
            }
        }

        function deleteChatWithActiveUser() {
            if(confirm('Delete history for both?')) {
                if(connections[activePeerId]?.dc) {
                    connections[activePeerId].dc.send(JSON.stringify({ type: 'wipe' }));
                }
                history[activePeerId] = [];
                saveHistory();
                renderMessages();
            }
        }

        function clearAllHistory() {
            if(confirm('Wipe everything?')) {
                localStorage.clear();
                history = {};
                location.reload();
            }
        }
    </script>
</body>
</html>
